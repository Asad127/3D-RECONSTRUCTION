%{ 
FIRST OF ALL: Run Calib_results.mat -- generated by Calibration Toolbox.

TERMINOLOGY:
- i'th pixel, j'th img / k'th view
- x_j is all the undistorted corner pixels
- X_j is the world coordinates for the checker corners in the j'th image
- [Rc_j | Tc_j] is the j'th view's pose
- KK_j (= K since one camera here) is the j'th camera's intrinsics
 
IMPORTANT:
y from Calib_Results.mat is corner pixels on the distorted image. This
script assumes images have been undistorted, so you should feed it the
undistorted locations. For that, you can just use the forward projection
equations with X_j for each view.
%}

%% SETUP %%
clc;
clear all;
close all

% Load the calibration results.
%load("matlab_zxc.mat");
%load("points_2_nimo3.mat");
%load('check_this.mat');
%load('page1.mat');
load('merged_params.mat');
load('points_48_nimo_column.mat');

%npoints = 2;         % no. of points to click
org_dist = 24;     % if square shapes
%org_dist_x = 13.5;  % in mm, between two neightbors along world Y 
%org_dist_y = 13.5;  % in mm, between two neightbors along world Y 

% Set optimizer options.
options = optimoptions('lsqnonlin', 'display', 'off', 'MaxIter', 500, 'MaxFunEvals', 6.240000e+05);
options.Algorithm = 'levenberg-marquardt';
%options.Algorithm = 'sqp';

% Input which images to use.
disp("When prompted, enter the image numbers in the form of a vector.") 
disp("For example, [1 5 10] for the 1st, 5th, and 10th image. Blank input means all.")
imgs_to_use = input("Which images to use? ([] = all): ");
if isempty(imgs_to_use)
    imgs_to_use = 1 : n_ima;
end
n_views = numel(imgs_to_use);
view = imgs_to_use;
if n_views > 3
    disp('[ERROR] Unsupported number of views. Enter only 2 or 3 images.');
    return
end

R = []; T = []; KK = []; 
% For each input image (view)...
for j = 1 : n_views
    k = view(j);  % indexing convenience - img no. for k'th view
    
    % Load corresponding extrinsics.
    eval(['R = [R Rc_' num2str(k) '];']);
    eval(['T = [T Tc_' num2str(k) '];']);  
    eval(['KK = [KK KK_' num2str(k) '];']);
%     % Load image and click points to estimate world coordinates of.
%     figure(j);
%     eval(['I = imread("undistorted/Image_rect' num2str(k) '.tif");']);
%     imshow(I); hold on;
%     xlabel('x (pixel)'); ylabel('y (pixel)');
%     if j == 1
%         title(['View ' num2str(j) ' (Img ' num2str(k) ') - Click any ' num2str(npoints) ' points']);
%     else
%         title(['View ' num2str(j) ' (Img ' num2str(k) ') - Click on ' num2str(npoints) ' corresponding points']);
%     end
%     for i = 1 : npoints
%         [x_click, y_click] = ginput(1);
%         plot(x_click, y_click, 'm+', 'linewidth', 1, 'MarkerSize', 8);
%         xj = [xj cat(2, x_click, y_click, 1)']; 
%     end
%     hold off;
end
%save('points.mat','xj')
% close all;
% Other pose options.
%xj = [x_cam_obj(1:3, :) x_cam_obj(7:9, :)]; 
%xj = [xj(:, 1:npoints) xj(:, 11:10+npoints*2)];

%% OPTIMIZATION PER PIXEL FOR N-VIEW WORLD COORDINATE ESTIMATION %%
% All "_check" variables are for other extrinsic options. Each optimization
% run is for one corner pixel at a time using both good and bad poses.

fprintf('\nEstimating world coordinates with lsqnonlin...')

X_init = ones(4, 1);         % initial guess for optimizer
X = zeros(4, npoints);       % to check correct extrinsics
xpp = zeros(3, n_views);     % to store each corner pixel individually for each view

% For each selected point...
for i = 1 : npoints
    % For each view of the checker...
    for j = 1 : n_views
        % Get pixel location of the same physical corner in all n views.
        xpp(:, j) = xj(:, npoints*(j-1)+i);
    end
    
    % Optimize for the world coordinates for both good and bad poses.
    Xpp = lsqnonlin(@(Xpp)reconst_coords_per_px(Xpp, n_views, xpp, KK, R, T), X_init, [], [], options);

    % Normalize w.r.t homogenous coordinate.
    Xpp = Xpp./Xpp(4);  
    
    % Append to array, will be 4 x npoints by end.
    X(:, i) = Xpp;      
end
fprintf(' done.\n')


%% CHECK RESULT BY PROJECTING TO IMAGE %%
fprintf('Reprojecting using the estimated world coordinates... ')
per_view_reproj_error = Inf(1, n_views);
for j = 1 : n_views
    if j == 2
        Xm = [];
        for i = 1 : size(X, 2)
            Xm = [Xm [X(2, i); X(1, i); X(3, i); X(4, i)]];
        end
%         for i = 1 : size(X, 2)
%             Xm = [Xm [X(1, i); -X(2, i); X(3, i); X(4, i)]];
%         end
    else
        Xm = X;
    end
    proj_pixels_org = xj(:, j*npoints-(npoints-1) : j*npoints);
    proj_pixels_est = KK(:, j*3-2:j*3) * [R(:, j*3-2:j*3) T(:, j)] * Xm; 
    proj_pixels_est = proj_pixels_est./proj_pixels_est(3, :);

    eval(['img = imread("Image' num2str(view(j)) '.jpg");']);
    
    reproj_error = mean(abs(proj_pixels_org - proj_pixels_est), 'all');
    per_view_reproj_error(1, j) = reproj_error;
    
    figure(j)
    imshow(img); hold on;
    title(['View ' num2str(j) ' (Img ' num2str(view(j)) ') - Pixel Projections for Estimated World Coordinates'])
    xlabel('x (pixel)'); ylabel('y (pixel)');
    plot(proj_pixels_est(1, :), proj_pixels_est(2, :), 'r*', 'linewidth', 1, 'MarkerSize', 7);
    plot(proj_pixels_org(1, :), proj_pixels_org(2, :), 'bo', 'linewidth', 1, 'MarkerSize', 8);
    legend('correct extrinsics est WC projections',  'original WC projections')
end
fprintf("done.\n")

X_est = X(1:3, :); 
figure(10);
%zlim([min(X_est(3, :)*50) max(X_est(3, :))*50]);
xlabel('X (mm)'); ylabel('Y (mm)'); zlabel('Z (mm)');
hold on; grid on;
% xlim([0 120 ]);
% ylim([0 120]);
% zlim([0 120]);
plot3(X_est(1, 1), X_est(2, 1), X_est(3, 1), 'r*')
plot3(X_est(1, 2:48), X_est(2, 2:48), X_est(3, 2:48), 'b*')
% xlim([-2 20]);
% ylim([0 250]);
% zlim([-2 8]);
% pose1 = rigid3d(Rc_1, Tc_1');
% pose2 = rigid3d(Rc_2, Tc_2');
% plotCamera(AbsolutePose = pose1, Color=[1 0 0]);
% plotCamera(AbsolutePose = pose2, Color=[0 1 0]);

% Display results.
disp('***CORRECT EXTRINSICS***');
fmt = ['\tMean Reprojection Error (PER-VIEW): ', repmat('%f, ', 1, numel(per_view_reproj_error(1, :))-1), '%f\n'];
fprintf(fmt, per_view_reproj_error(1,:));
fprintf('\tMean Reprojection Error (OVERALL): %f\n', mean(per_view_reproj_error(1, :), 'all'));

fprintf('\n\t*** ESTIMATED WORLD COORDS ***\n');
fprintf('\tOriginal Distances: X = %4.4f\n', org_dist)
fmt = ['\tEstimated 3D Points: ', repmat('(%4.4f, %4.4f, %4.4f), ', 1, npoints - 1), '(%4.4f, %4.4f, %4.4f)\n'];
fprintf(fmt, X_est);

est_dist = NaN(1, npoints - 1);
for i = 1 : npoints - 1
    est_dist(i) = norm(X_est(:, i) - X_est(:, i+1), 2);
end
fmt = ['\tNormed Distance Between Neighboring Points: ', repmat('%4.4f, ', 1, numel(est_dist) - 1), '%4.4f\n'];
fprintf(fmt, est_dist);
dd=mean(est_dist);
%fprintf("Mean of est dis is\n:",dd);
error_dist = est_dist - org_dist;
fmt = ['\tErrors w.r.t Original Distances: ', repmat('%4.4f, ', 1, numel(est_dist) - 1), '%4.4f\n'];
fprintf(fmt, error_dist);
disp(dd)
fprintf('\n\tMean Distance Error: %4.4f\n', mean(error_dist, 'all'))
orignan_2d = sqrt(sum((proj_pixels_org - proj_pixels_est).^2));
figure(20);
%histogram(error_dist, 20);
%D=sqrt((y(1)-x(1))^2+(y(2)-x(2))^2);
histogram(orignan_2d, 110);
xlabel('X (mm)'); ylabel('Y (mm)'); 
%histogram(error_dist, 20);
%D=sqrt((y(1)-x(1))^2+(y(2)-x(2))^2);
hold on;
%% FUNCTIONS %%
function error = reconst_coords_per_px(X, n_views, x, K, R, T)
% lsqnonlin needs the vectored error (i.e., error has components), so we
% need to stack the pixel reprojection error for each view.
vector_err = [];
for j = 1 : n_views
    % Slice magic. Try dry-running for a couple iters to recap why.
    true = x(:, j);
     
    if j == 2
        X = [X(2); X(1); X(3); X(4)];
    end
    
%     if j == 2       % mirror condition 180 deg flip about z-axis
%         X = [X(1); -X(2); X(3); X(4)];
%     end
    
    pred = K(:, j*3-2:j*3)* [R(:, j*3-2:j*3) T(:, j)] * X;
    
    % Normalize w.r.t. homogenous coordinate
    pred = pred./pred(3, :);  
    
    % Get the reprojection error and vectorize it.
    reproj_error = true - pred;
    vector_err = [vector_err reproj_error];
end
error = vector_err;
end
